Title: Subclassing Java Classes in JPython



<h3>Subclassing Java Classes in JPython</h3>

<h3>A Short Example</h3>

The example below should both demonstrate how this subclassing is
performed and why it is useful.  At first glance, the code looks
exactly like subclassing any other Python class.  The key difference
in this example is that awt.event.ActionListener is a Java class, not
a Python one.  In the 4th line from the end,
"b.addListener(SpamListener())",
a Java method is being called that
requires an instance of the Java class ActionListener. By providing a
Python subclass of this Java class, everybody is happy.

<PRE>
from java import awt

class SpamListener(awt.event.ActionListener):
    def actionPerformed(self,event):
        if event.getActionCommand() == "Spam":
	    print 'Spam and eggs!'
</PRE>

<PRE>
f = awt.Frame("Subclassing Example")
b = awt.Button("Spam")
b.addActionListener(SpamListener())
f.add(b, "Center")
f.pack()
f.setVisible(1)
</PRE>

Note: This example can be accomplished much more elegantly by using
<A HREF="properties.html">JavaBeans properties 
(and event properties)</A>.

<h3>Calling Methods in Your Superclass</h3>

In Python, if I want to call the foo method in my superclass, I use
the form:

<PRE>SuperClass.foo(self)</PRE>

If SuperClass is a Java class instead of a Python one, I must instead
use the form:

<PRE>self.super__foo()</PRE>

For every method in SuperClass, one of the magic "super__" methods
will be created that can be used to call it.  This difference is
required by the different method lookup semantics in Python and Java
and I think the current solution is the best that can be found.

<h3>Example</h3>

The following example shows how the java.io.InputStream class can be
effectively subclassed.  What makes this class difficult is that the
read method is overloaded for three different method signatures:

<OL>
    <LI>abstract int read()</LI>
    <LI>int read(byte[])</LI>
    <LI>int read(byte[], int, int)</LI>
</OL>

The first one of these methods must be overridden in a subclass.
The other two versions can be ignored.  Unfortunately, Python has
no notion of method overloading based on type signatures (this might
be related to the fact that Python doesn't have type signatures
;-)  In order to implement a subclass of java.io.InputStream that
overrides the "read" method, a Python method must be implemented that
handles all three possible cases.  The example below shows the easiest
way to acheive this:

<PRE>
from java.io import InputStream

class InfiniteOnes(InputStream):
    def read(self, *args):
        if len(args) > 0:
            return apply(self.super__read, args)
        return 1

io = InfiniteOnes()

for i in range(10):
    print io.read(),
print
</PRE>

<h3>Example Continued</h3>

To continue the example above, this new instance of
java.io.InputStream can be passed to any Java method that expects an
InputStream as shown below:

<PRE>
from java.io import DataInputStream

dp = DataInputStream(io)
dp.skipBytes(1000)
print dp.readByte()
print dp.readShort()
print dp.readInt()
</PRE>

<h3>Invoking Your Superclass's Constructor</h3>

You can explictly invoke your superclass's constructor using the
standard Python syntax of explictly calling the "__init__" method on
the superclass and passing in "self" as the first argument.  If you
wish to call your superclass's constructor, you must do so within your
own "__init__" method.  When your "__init__" method finishes, if your
Java superclasses have not yet been explicitly initialized, their
empty constructors will be called at this point.

<P>It's important to realize that your superclass is not initialized
until you either explictly call it's "__init__" method, or your own
"__init__" method terminates.  You must do one of these two things
before accessing any methods in your superclass.

<h3>Example</h3>

<PRE>
from java.util import Random

class rand(Random):
    def __init__(self, multiplier=1.0, seed=None):
        self.multiplier = multiplier
        if seed is None:
            Random.__init__(self)
        else: 
            Random.__init__(self, seed)

    def nextDouble(self):
        return self.super__nextDouble()*self.multiplier

r = rand(100, 23)

for i in range(10):
    print r.nextDouble(),
print
</PRE>

This example shows how the superclass's constructor can be effectively
called in order to explictly choose a non-empty version.

<h3>Caching Proxy Classes (Efficiency)</h3>

In order to subclass from a Java class, a Java proxy class must be
created by JPython.  This proxy class is a true Java subclass of the
class you wish to subclass from in Python.  If you do nothing special,
these proxy classes will be created on the fly whenever one is needed.
I you find that the time required for generating these proxies is a
problem, you have two options for convincing JPython to use a cache
instead of recreating them every time.

<P>You can set the "python.proxy.savedir" variable in your registry
file.  You must set this to point to a directory in your Java
Classpath.  I strongly reccommend setting it to &lt;JPYTHON>/JavaCode
where JPython is the directory into which the distribution was
installed.  This will cause JPython to cache copies of any new proxy
classes that it creates.

<P>You can also explicitly create proxy classes with the following
command:

<PRE>java org.python.compiler.ProxyMaker &lt;directory> &lt;classname></PRE>

This will create the proxy class for a given Java class and install it
in the given directory (which must be on your Java Classpath - see
above).

<P>The danger of these caching mechanisms is that JPython currently
has no way to invalidate this cache.  So if you install an improved
version of JPython that produces different proxy files, or if you
modify one of the classes to which you've previously created a proxy,
the change won't be properly handled.  So, only use proxy class
caching if you feel comfortable with JPython already, and if you start
running into problems with proxy classes, my first suggestion is to
disable proxy class caching and to delete your cache directory
(&lt;directory>/org/python/proxies).