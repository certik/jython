package org.python.modules;

import org.python.core.*;

/**
 * This file contains autogenerated error codes from:<br/>
 *  <b>Python 2.2.1 (#34, Apr  9 2002, 19:34:33) [MSC 32 bit (Intel)]</b>
 *
 * @author brian zimmer
 * @version 2.2.1
 * @copyright 2002 brian zimmer
 */
public final class errno implements ClassDictInit {

    public static final int EPERM                     = 1;
    public static final int ENOENT                    = 2;
    public static final int ESRCH                     = 3;
    public static final int EINTR                     = 4;
    public static final int EIO                       = 5;
    public static final int ENXIO                     = 6;
    public static final int E2BIG                     = 7;
    public static final int ENOEXEC                   = 8;
    public static final int EBADF                     = 9;
    public static final int ECHILD                    = 10;
    public static final int EAGAIN                    = 11;
    public static final int ENOMEM                    = 12;
    public static final int EACCES                    = 13;
    public static final int EFAULT                    = 14;
    public static final int EBUSY                     = 16;
    public static final int EEXIST                    = 17;
    public static final int EXDEV                     = 18;
    public static final int ENODEV                    = 19;
    public static final int ENOTDIR                   = 20;
    public static final int EISDIR                    = 21;
    public static final int EINVAL                    = 22;
    public static final int ENFILE                    = 23;
    public static final int EMFILE                    = 24;
    public static final int ENOTTY                    = 25;
    public static final int EFBIG                     = 27;
    public static final int ENOSPC                    = 28;
    public static final int ESPIPE                    = 29;
    public static final int EROFS                     = 30;
    public static final int EMLINK                    = 31;
    public static final int EPIPE                     = 32;
    public static final int EDOM                      = 33;
    public static final int ERANGE                    = 34;
    public static final int EDEADLOCK                 = 36;
    public static final int ENAMETOOLONG              = 38;
    public static final int ENOLCK                    = 39;
    public static final int ENOSYS                    = 40;
    public static final int ENOTEMPTY                 = 41;
    public static final int EILSEQ                    = 42;

    public static final PyObject errorcode = new PyDictionary();
    private static final PyObject strerror = new PyDictionary();

    public static void classDictInit(PyObject dict) throws PyIgnoreMethodTag {
        addcode(dict, EPERM, "EPERM", "Operation not permitted");
        addcode(dict, ENOENT, "ENOENT", "No such file or directory");
        addcode(dict, ESRCH, "ESRCH", "No such process");
        addcode(dict, EINTR, "EINTR", "Interrupted function call");
        addcode(dict, EIO, "EIO", "Input/output error");
        addcode(dict, ENXIO, "ENXIO", "No such device or address");
        addcode(dict, E2BIG, "E2BIG", "Arg list too long");
        addcode(dict, ENOEXEC, "ENOEXEC", "Exec format error");
        addcode(dict, EBADF, "EBADF", "Bad file descriptor");
        addcode(dict, ECHILD, "ECHILD", "No child processes");
        addcode(dict, EAGAIN, "EAGAIN", "Resource temporarily unavailable");
        addcode(dict, ENOMEM, "ENOMEM", "Not enough space");
        addcode(dict, EACCES, "EACCES", "Permission denied");
        addcode(dict, EFAULT, "EFAULT", "Bad address");
        addcode(dict, EBUSY, "EBUSY", "Resource device");
        addcode(dict, EEXIST, "EEXIST", "File exists");
        addcode(dict, EXDEV, "EXDEV", "Improper link");
        addcode(dict, ENODEV, "ENODEV", "No such device");
        addcode(dict, ENOTDIR, "ENOTDIR", "Not a directory");
        addcode(dict, EISDIR, "EISDIR", "Is a directory");
        addcode(dict, EINVAL, "EINVAL", "Invalid argument");
        addcode(dict, ENFILE, "ENFILE", "Too many open files in system");
        addcode(dict, EMFILE, "EMFILE", "Too many open files");
        addcode(dict, ENOTTY, "ENOTTY", "Inappropriate I/O control operation");
        addcode(dict, EFBIG, "EFBIG", "File too large");
        addcode(dict, ENOSPC, "ENOSPC", "No space left on device");
        addcode(dict, ESPIPE, "ESPIPE", "Invalid seek");
        addcode(dict, EROFS, "EROFS", "Read-only file system");
        addcode(dict, EMLINK, "EMLINK", "Too many links");
        addcode(dict, EPIPE, "EPIPE", "Broken pipe");
        addcode(dict, EDOM, "EDOM", "Domain error");
        addcode(dict, ERANGE, "ERANGE", "Result too large");
        addcode(dict, EDEADLOCK, "EDEADLOCK", "Resource deadlock avoided");
        addcode(dict, ENAMETOOLONG, "ENAMETOOLONG", "Filename too long");
        addcode(dict, ENOLCK, "ENOLCK", "No locks available");
        addcode(dict, ENOSYS, "ENOSYS", "Function not implemented");
        addcode(dict, ENOTEMPTY, "ENOTEMPTY", "Directory not empty");
        addcode(dict, EILSEQ, "EILSEQ", "Illegal byte sequence");

    }

    public static PyObject strerror(PyObject error) {
        return strerror.__getitem__(error);
    }

    private static void addcode(PyObject dict, int errno,
                                String err, String msg) {
        PyObject errno_o = Py.newInteger(errno);
        PyObject err_o = Py.newString(err);
        strerror.__setitem__(errno_o, Py.newString(msg));
        errorcode.__setitem__(errno_o, err_o);
        dict.__setitem__(err_o, errno_o);
    }
}
