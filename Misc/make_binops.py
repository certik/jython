"""generates code for binops in PyObject and for all "simple" ops in PyInstance"""

binops = \
	[('add', '+'), ('sub', '-'), ('mul', '*'), ('div', '/'),
	 ('mod', '%'), ('divmod', 'divmod'), ('pow', '**'), 
	 ('lshift', '<<'), ('rshift', '>>'), ('and', '&'), ('or', '|'), ('xor', '^')]

template = """\
	/**Equivalent to the standard Python __%(name)s__ method
	@param other the object to perform this binary operation with (the right-hand operand).
	@return the result of the %(name)s, or null if this operation is not defined
	**/
	public PyObject __%(name)s__(PyObject other) { %(function)s }
	
	/**Equivalent to the standard Python __r%(name)s__ method
	@param other the object to perform this binary operation with (the left-hand operand).
	@return the result of the %(name)s, or null if this operation is not defined.
	**/
	public PyObject __r%(name)s__(PyObject other) { %(rfunction)s }

	/**Implements the Python expression <code>this %(op)s other</code>
	@param other the object to perform this binary operation with.
	@return the result of the %(name)s.
	@exception PyTypeError if this operation can't be performed with these operands.
	**/
	public final PyObject _%(name)s(PyObject o2_in) throws PyTypeError{
		PyObject o2 = o2_in;
		PyObject o1 = this;
		Object ctmp;
		if (o1.__class__ != o2.__class__) {
			ctmp=o1.__coerce_ex__(o2);
			if (ctmp != null) {
				if (ctmp instanceof PyObject[]) { o1 = ((PyObject[])ctmp)[0]; o2 = ((PyObject[])ctmp)[1];
				} else { o2 = (PyObject)ctmp; }
			}
		} else ctmp = null;
		if (ctmp != Py.None && (o1 = o1.__%(name)s__(o2)) != null) return o1;
		o1 = this;
		o2 = o2_in;
		if (o1.__class__ != o2.__class__) {
			ctmp=o2.__coerce_ex__(o1);
			if (ctmp != null) {
				if (ctmp instanceof PyObject[]) { o2 = ((PyObject[])ctmp)[0]; o1 = ((PyObject[])ctmp)[1];
				} else { o1 = (PyObject)ctmp; }
			}
		}
		if (ctmp != Py.None) {
			if (o1.__class__ == o2.__class__) o1 = o1.__%(name)s__(o2);
			else o1 = o2.__r%(name)s__(o1);
			if (o1 != null) return o1;
		}
		throw new PyTypeError("__%(name)s__ nor __r%(name)s__ defined for these operands");
	}

"""

fp = open('c:\\jpython\\JavaCode\\org\\python\\core\\binops.txt', 'w')

for name, op in binops:
	rfunction = function = 'return null;'

	if name == 'pow':
		function = 'return __pow__(other, null);'
	
	fp.write(template % {'name':name, 'op':op, 'function':function, 'rfunction':rfunction})

fp.close()



fp = open('c:\\jpython\\JavaCode\\org\\python\\core\\binopsi.txt', 'w')

fp.write('\t// Generated by make_binops.py\n\n')

comment = """\
	/**
	Implements the __%(name)s__ method by looking it up
	in the instance's dictionary and calling it if it is found.
	**/
"""

template1 = comment + """\
	public %(ret)s __%(name)s__() {
		PyObject ret = invoke("__%(name)s__");
		if (ret instanceof %(ret)s) return (%(ret)s)ret;
		throw new PyTypeError("__%(name)s__() should return a %(retname)s");
	}
	
"""
template2 = comment + """\
	public PyObject __%(name)s__() {
		return invoke("__%(name)s__");
	}
	
"""

string = 'PyString', 'string'
ops = [('hex', string), ('oct', string), 
		('int', ('PyInteger', 'int')), ('float', ('PyFloat', 'float')), 
		('long', ('PyLong', 'long')), ('complex', ('PyComplex', 'complex')),
		('pos', None), ('neg', None), ('abs', None), ('invert', None)]
	
fp.write('\t// Unary ops\n\n')	
for name, ret in ops:
	if ret is None:
		fp.write(template2 % {'name':name})
	else:
		ret, retname = ret
		fp.write(template1 % {'name':name, 'ret':ret, 'retname':retname})



template = comment + """\
	public PyObject __%(name)s__(PyObject o) {
		return invoke_ex("__%(name)s__", o);
	}
	
"""

fp.write('\t// Binary ops\n\n')
for name, op in binops:	
	fp.write(template % {'name':name})
	fp.write(template % {'name':'r'+name})


fp.close()

